{"version":3,"file":"jose.min.js","mappings":"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","sources":["webpack://JOSE/./src/algorithms/SupportedAlgorithms.js","webpack://JOSE/./src/index.js","webpack://JOSE/./src/jose/JWKSet.js","webpack://JOSE/./src/errors/NotSupportedError.js","webpack://JOSE/./src/text-encoder/index.js","webpack://JOSE/./src/algorithms/NONE.js","webpack://JOSE/./src/algorithms/index.js","webpack://JOSE/./src/jose/JWT.js","webpack://JOSE/./src/errors/DataError.js","webpack://JOSE/./src/algorithms/RSASSA-PKCS1-v1_5.js","webpack://JOSE/./src/algorithms/ECDSA.js","webpack://JOSE/./src/algorithms/HMAC.js","webpack://JOSE/./src/jose/JWA.js","webpack://JOSE/./src/jose/JOSEHeader.js","webpack://JOSE/./node_modules/base64url/index.js","webpack://JOSE/external var \"TextEncoder\"","webpack://JOSE/./src/jose/JWS.js","webpack://JOSE/./node_modules/base64url/dist/base64url.js","webpack://JOSE/./src/jose/JWK.js","webpack://JOSE/external var \"crypto\"","webpack://JOSE/./src/errors/index.js","webpack://JOSE/./node_modules/base64url/dist/pad-string.js","webpack://JOSE/./src/crypto.js","webpack://JOSE/webpack/bootstrap","webpack://JOSE/webpack/runtime/global","webpack://JOSE/webpack/startup"],"sourcesContent":["/**\n * Dependencies\n */\nconst NotSupportedError = require('../errors/NotSupportedError')\n\n/**\n * Operations\n */\nconst operations = [\n  'sign',\n  'verify',\n  'encrypt',\n  'decrypt',\n  'importKey'\n]\n\n/**\n * SupportedAlgorithms\n */\nclass SupportedAlgorithms {\n\n  /**\n   * constructor\n   */\n  constructor () {\n    operations.forEach(op => {\n      this[op] = {}\n    })\n  }\n\n  /**\n   * Supported Operations\n   */\n  static get operations () {\n    return operations\n  }\n\n  /**\n   * define\n   *\n   * @description\n   * Register Web Crypto API algorithm parameter for an algorithm\n   * and operation.\n   *\n   * @param {string} alg\n   * @param {string} op\n   * @param {Object} argument\n   */\n  define (alg, op, argument) {\n    let registeredAlgorithms = this[op]\n    registeredAlgorithms[alg] = argument\n  }\n\n  /**\n   * normalize\n   *\n   * @description\n   * Map JWA alg name to Web Crypto API algorithm parameter\n   *\n   * @param {string} op\n   * @param {Object} alg\n   *\n   * @returns {Object}\n   */\n  normalize (op, alg) {\n    let registeredAlgorithms = this[op]\n\n    if (!registeredAlgorithms) {\n      return new SyntaxError() // what kind of error should this be?\n    }\n\n    let argument = registeredAlgorithms[alg]\n\n    if (!argument) {\n      return new NotSupportedError(alg)\n    }\n\n    return argument\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = SupportedAlgorithms\n","/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nconst crypto = require('./crypto')\nconst JWA = require('./jose/JWA')\nconst JWK = require('./jose/JWK')\nconst JWKSet = require('./jose/JWKSet')\nconst JWT = require('./jose/JWT')\nconst JWS = require('./jose/JWS')\n\n/**\n * Export\n */\nmodule.exports = {\n  crypto,\n  JWA,\n  JWK,\n  JWKSet,\n  JWT,\n  JWS\n}\n","'use strict'\n\n/**\n * Dependencies\n */\nconst JWK = require('./JWK')\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\nclass JWKSet {\n  constructor ({ keys } = {}) {\n    this.keys = keys\n  }\n\n  /**\n   * importKeys\n   */\n  static async importKeys (jwks) {\n    if (!jwks.keys) {\n      return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'))\n    }\n\n    let imported, importing\n\n    try {\n      imported = new JWKSet(jwks)\n      importing = jwks.keys.map(key => JWK.importKey(key))\n    } catch (err) {\n      return Promise.reject(err)\n    }\n\n    return Promise.all(importing)\n      .then(keys => {\n        imported.keys = keys\n        return imported\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWKSet\n","/**\n * NotSupportedError\n */\nclass NotSupportedError extends Error {\n  constructor (alg) {\n    super()\n    this.message = `${alg} is not a supported algorithm`\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = NotSupportedError\n","const TextEncoder = global.TextEncoder\n  ? global.TextEncoder  // browser\n  : require('@sinonjs/text-encoding').TextEncoder  // node shim\nmodule.exports = TextEncoder\n","/**\n * None\n */\nclass None {\n  /**\n   * sign\n   */\n  sign () {\n    return Promise.resolve('')\n  }\n\n  /**\n   * verify\n   */\n  verify () {\n    // this will never get called. but you looked.\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = None\n","/**\n * Local dependencies\n */\nconst None = require('./NONE')\nconst HMAC = require('./HMAC')\nconst RSASSA_PKCS1_v1_5 = require('./RSASSA-PKCS1-v1_5')\nconst ECDSA = require('./ECDSA')\nconst SupportedAlgorithms = require('./SupportedAlgorithms')\n\n/**\n * Register Supported Algorithms\n */\nconst supportedAlgorithms = new SupportedAlgorithms\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'sign', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}))\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'verify', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}))\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}))\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}))\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}))\n\nsupportedAlgorithms.define('ES256', 'importKey', new ECDSA({\n  name: 'ECDSA',\n  hash: {\n    name: 'SHA-256'\n  },\n  namedCurve: 'P-256'\n}))\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms\n\n\n","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWS = require('./JWS')\nconst DataError = require('../errors/DataError')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWT\n */\nclass JWT {\n  constructor (data = {}) {\n    this.type = data.type\n    this.segments = data.segments\n    this.header = new JOSEHeader(data.header)\n    this.protected = data.protected\n    this.unprotected = data.unprotected\n    this.iv = data.iv\n    this.aad = data.aad\n    this.ciphertext = data.ciphertext\n    this.tag = data.tag\n    this.recipients = data.recipients\n    this.payload = data.payload\n    this.signatures = data.signatures\n    this.signature = data.signature\n    this.key = data.key\n    this.serialization = data.serialization || 'compact' // default\n  }\n\n  /**\n   * decode\n   *\n   * @description\n   * Decode a JSON Web Token\n   *\n   * @param {string} data\n   * @returns {JWT}\n   */\n  static decode (data) {\n    let ExtendedJWT = this\n    let jwt\n\n    if (typeof data !== 'string') {\n      throw new DataError('JWT must be a string')\n    }\n\n    // JSON of Flattened JSON Serialization\n    if (data.startsWith('{')) {\n      try {\n        data = JSON.parse(data, () => {})\n      } catch (error) {\n        throw new DataError('Invalid JWT serialization')\n      }\n\n      if (data.signatures || data.recipients) {\n        data.serialization = 'json'\n      } else {\n        data.serialization = 'flattened'\n      }\n\n      jwt = new ExtendedJWT(data, { filter: false })\n\n    // Compact Serialization\n    } else {\n      try {\n        let serialization = 'compact'\n        let segments = data.split('.')\n        let length = segments.length\n\n        if (length !== 3 && length !== 5) {\n          throw new Error('Malformed JWT')\n        }\n\n        let header = JSON.parse(base64url.decode(segments[0]))\n\n        // JSON Web Signature\n        if (length === 3) {\n          let type = 'JWS'\n          let payload = JSON.parse(base64url.decode(segments[1]))\n          let signature = segments[2]\n\n          jwt = new ExtendedJWT(\n              { type, segments, header, payload, signature, serialization },\n              { filter: false }\n            )\n        }\n\n        // JSON Web Encryption\n        if (length === 5) {\n          //let type = 'JWE'\n          //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n          //jwt = new ExtendedJWT({\n          //  type,\n          //  protected: base64url.decode(JSON.parse(protected)),\n          //  encryption_key,\n          //  iv,\n          //  ciphertext,\n          //  tag,\n          //  serialization\n          //})\n        }\n      } catch (error) {\n        throw new DataError('Invalid JWT compact serialization')\n      }\n    }\n\n    return jwt\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JSON Web Token\n   *\n   * @param {Object} header\n   * @param {Object} payload\n   * @param {CryptoKey} key\n   *\n   * @returns {Promise}\n   */\n  static encode (header, payload, key) {\n    let jwt = new JWT(header, payload)\n    return jwt.encode(key)\n  }\n\n\n  /**\n   * verify\n   *\n   * @description\n   *\n   * @param {CryptoKey} key\n   * @param {string} token\n   *\n   * @returns {Promise}\n   */\n  static async verify (key, token) {\n    let jwt = JWT.decode(token)\n    jwt.key = key\n    return jwt.verify().then(verified => jwt)\n  }\n\n  /**\n   * isJWE\n   */\n  isJWE () {\n    return !!this.header.enc\n  }\n\n  /**\n   * resolveKeys\n   */\n  resolveKeys (jwks) {\n    let kid = this.header.kid\n    let keys, match\n\n    // treat an array as the \"keys\" property of a JWK Set\n    if (Array.isArray(jwks)) {\n      keys = jwks\n    }\n\n    // presence of keys indicates object is a JWK Set\n    if (jwks.keys) {\n      keys = jwks.keys\n    }\n\n    // wrap a plain object they is not a JWK Set in Array\n    if (!jwks.keys && typeof jwks === 'object') {\n      keys = [jwks]\n    }\n\n    // ensure there are keys to search\n    if (!keys) {\n      throw new DataError('Invalid JWK argument')\n    }\n\n    // match by \"kid\" or \"use\" header\n    if (kid) {\n      match = keys.find(jwk => jwk.kid === kid)\n    } else {\n      match = keys.find(jwk => jwk.use === 'sig')\n    }\n\n    // assign matching key to JWT and return a boolean\n    if (match) {\n      this.key = match.cryptoKey\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * encode\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @returns {Promise}\n   */\n  async encode () {\n    let token = this\n\n    if (this.isJWE()) {\n      return JWE.encrypt(token)\n    } else {\n      return JWS.sign(token)\n    }\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a decoded JWT instance\n   *\n   * @returns {Promise}\n   */\n  async verify () {\n    return JWS.verify(this)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWT\n","/**\n * DataError\n */\nclass DataError extends Error {\n  constructor (message) {\n    super(message)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = DataError\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nlet crypto = require('../crypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * RSASSA-PKCS1-v1_5\n */\nclass RSASSA_PKCS1_v1_5 {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO\n    //if (!this.sufficientKeySize()) {\n    //  return Promise.reject(\n    //    new Error(\n    //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n    //    )\n    //  )\n    //}\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} signature\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n    // ...\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * importKey\n   *\n   * @param {JWK} key\n   * @returns {Promise}\n   */\n  async importKey (key) {\n    let jwk = Object.assign({}, key)\n    let algorithm = this.params\n    let usages = key['key_ops'] || []\n\n    if (key.use === 'sig') {\n      usages.push('verify')\n    }\n\n    if (key.use === 'enc') {\n      // TODO: handle encryption keys\n      return Promise.resolve(key)\n    }\n\n    if (key.key_ops) {\n      usages = key.key_ops\n    }\n\n    return crypto.subtle\n      .importKey('jwk', jwk, algorithm, true, usages)\n      .then(cryptoKey => {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        })\n\n        return jwk\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = RSASSA_PKCS1_v1_5\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nconst crypto = require('isomorphic-webcrypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * ECDSA with SHA-2 Functions and P Curves\n */\nclass ECDSA {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO: validate key length\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {string} signature\n   * @param {string} data\n   *\n   * @returns {Boolean}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * Assert Sufficient Key Length\n   *\n   * @description Assert that the key length is sufficient\n   * @param {string} key\n   */\n  assertSufficientKeyLength (key) {\n    if (key.length < this.bitlength) {\n      throw new Error('The key is too short.')\n    }\n  }\n\n  /**\n   * importKey\n   * copied from ./RSASSA-PKCS1-v1_5.js, and it works!\n   *\n   * @param {JWK} key\n   * @returns {Promise}\n   */\n  async importKey (key) {\n    let jwk = Object.assign({}, key)\n    let algorithm = this.params\n    let usages = key['key_ops'] || []\n\n    if (key.use === 'sig') {\n      usages.push('verify')\n    }\n\n    if (key.use === 'enc') {\n      // TODO: handle encryption keys\n      return Promise.resolve(key)\n    }\n\n    if (key.key_ops) {\n      usages = key.key_ops\n    }\n\n    return crypto.subtle\n      .importKey('jwk', jwk, algorithm, true, usages)\n      .then(cryptoKey => {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        })\n\n        return jwk\n      })\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = ECDSA\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst base64url = require('base64url')\nconst crypto = require('isomorphic-webcrypto')\nconst TextEncoder = require('../text-encoder')\n\n/**\n * HMAC with SHA-2 Functions\n */\nclass HMAC {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  constructor (params) {\n    this.params = params\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n  sign (key, data) {\n    let algorithm = this.params\n\n    // TODO: validate key length\n\n    data = new TextEncoder().encode(data)\n\n    return crypto.subtle\n      .sign(algorithm, key, data)\n      .then(signature => base64url(Buffer.from(signature)))\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {string} signature\n   * @param {string} data\n   *\n   * @returns {Boolean}\n   */\n  verify (key, signature, data) {\n    let algorithm = this.params\n\n    if (typeof signature === 'string') {\n      signature = Uint8Array.from(base64url.toBuffer(signature))\n    }\n\n    if (typeof data === 'string') {\n      data = new TextEncoder().encode(data)\n    }\n\n    return crypto.subtle.verify(algorithm, key, signature, data)\n  }\n\n  /**\n   * Assert Sufficient Key Length\n   *\n   * @description Assert that the key length is sufficient\n   * @param {string} key\n   */\n  assertSufficientKeyLength (key) {\n    if (key.length < this.bitlength) {\n      throw new Error('The key is too short.')\n    }\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = HMAC\n","/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\n// const base64url = require('base64url')\nconst supportedAlgorithms = require('../algorithms')\nconst {NotSupportedError} = require('../errors')\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\nclass JWA {\n\n  /**\n   * Sign\n   *\n   * @description\n   * Create a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} key\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async sign (alg, key, data) {\n    // normalize the algorithm\n    let normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg)\n\n    // validate algorithm is supported\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // validate type of key\n    // TODO\n    //  - is the key suitable for the algorithm?\n    //  - does that get validated in webcrypto?\n    //if (key instanceof CryptoKey) {\n    //  return Promise.reject(new InvalidKeyError())\n    //}\n\n    // sign the data\n    return normalizedAlgorithm.sign(key, data)\n  }\n\n  /**\n   * Verify\n   *\n   * @description\n   * Verify a digital signature.\n   *\n   * @param {string} alg\n   * @param {CryptoKey} privateKey\n   * @param {string|Buffer} signature\n   * @param {string|Buffer} data\n   *\n   * @return {Promise}\n   */\n  static async verify (alg, key, signature, data) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg)\n\n    if (normalizedAlgorithm instanceof Error) {\n      return Promise.reject(new NotSupportedError(alg))\n    }\n\n    // TODO\n    // validate publicKey\n\n    // verify the signature\n    return normalizedAlgorithm.verify(key, signature, data)\n  }\n\n  /**\n   * Encrypt\n   */\n\n  /**\n   * Decrypt\n   */\n\n  /**\n   * Import\n   */\n  static async importKey (key) {\n    let normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg)\n    return normalizedAlgorithm.importKey(key)\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWA\n","/**\n * Header\n */\nclass JOSEHeader {\n  constructor ({ typ, cty, alg, jku, kid, x5u, x5c, x5t, crit, enc, zip } = {}) {\n    this.typ = typ\n    this.cty = cty\n    this.alg = alg\n    this.jku = jku\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n    this.crit = crit\n    this.enc = enc\n    this.zip = zip\n  }\n\n  /**\n   * isJWS\n   */\n  isJWS () {}\n\n  /**\n   * isJWE\n   */\n  isJWE () {}\n}\n\n/**\n * Export\n */\nmodule.exports = JOSEHeader\n","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n","module.exports = TextEncoder;","/**\n * Dependencies\n */\nconst base64url = require('base64url')\nconst JWA = require('./JWA')\nconst { DataError } = require('../errors')\nconst JOSEHeader = require('./JOSEHeader')\n\n/**\n * JWS\n */\nclass JWS {\n  constructor (data = {}) {\n    // compact\n    this.header = new JOSEHeader(data.header)\n    this.payload = data.payload || {}\n    this.signature = data.signature\n\n    // flattened\n    this.protected = data.protected\n\n    // JSON serialization\n    this.signatures = data.signatures\n\n    this.verified = false\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Encode a JWT instance\n   *\n   * @param {Object} token\n   * @returns {Promise}\n   */\n  static async sign (token) {\n    let payload = base64url(JSON.stringify(token.payload))\n\n    // compact serialization\n    if (token.serialization === 'compact') {\n      let {key, header: {alg}} = token\n      let header = base64url(JSON.stringify(token.header))\n      let data = `${header}.${payload}`\n\n      return JWA.sign(alg, key, data).then(signature => `${data}.${signature}`)\n    }\n\n    // JSON serialization\n    if (token.serialization === 'json') {\n\n    }\n\n    // Flattened serialization\n    if (token.serialization === 'flattened') {\n\n    }\n\n    return Promise.reject(new DataError('Unsupported serialization'))\n  }\n\n  /**\n   * verify\n   */\n  static async verify (jwt) {\n    // multiple signatures\n    if (jwt.signatures) {\n      // ...\n    }\n\n    let {key, signature, header: {alg}} = jwt\n\n    // one signature\n    if (jwt.signature) {\n      let [header, payload] = jwt.segments\n      let data = `${header}.${payload}`\n\n      if (alg === 'none') {\n        return Promise.reject(new DataError('Signature provided to verify with alg: none'))\n      }\n\n      return JWA.verify(alg, key, signature, data).then(verified => {\n        jwt.verified = verified\n        return verified\n      })\n    }\n\n    if (alg === 'none') {\n      if (!key && !signature) {\n        jwt.verified = true\n\n        return Promise.resolve(true)\n      }\n\n      if (key) {\n        return Promise.reject(new DataError('Key provided to verify signature with alg: none'))\n      }\n    }\n\n    // no signatures to verify\n    return Promise.reject(new DataError('Missing signature(s)'))\n  }\n}\n\n/**\n * Export\n */\nmodule.exports = JWS\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n","'use strict'\n\n/**\n * Dependencies\n * @ignore\n */\nconst JWA = require('./JWA')\n\n/**\n * JWK Class\n */\nclass JWK {\n  constructor ({ kty, use, key_ops, alg, kid, x5u, x5c, x5t } = {}) {\n    this.kty = kty\n    this.use = use\n    this.key_ops = key_ops\n    this.alg = alg\n    this.kid = kid\n    this.x5u = x5u\n    this.x5c = x5c\n    this.x5t = x5t\n  }\n\n  /**\n   * importKey\n   *\n   * TODO:\n   * - should this be on JWA?\n   */\n  static async importKey (jwk) {\n    return JWA.importKey(jwk)\n  }\n\n\n}\n\n/**\n * Export\n */\nmodule.exports = JWK\n","module.exports = crypto;","module.exports = {\n  DataError: require('./DataError'),\n  NotSupportedError: require('./NotSupportedError')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n","const imported = require('isomorphic-webcrypto')\n\nmodule.exports = (imported.default ? imported.default : imported)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(44);\n"],"names":["NotSupportedError","operations","module","exports","constructor","forEach","op","this","define","alg","argument","normalize","registeredAlgorithms","SyntaxError","crypto","JWA","JWK","JWKSet","JWT","JWS","keys","importKeys","jwks","Promise","reject","Error","imported","importing","map","key","importKey","err","all","then","super","message","TextEncoder","g","sign","resolve","verify","None","HMAC","RSASSA_PKCS1_v1_5","ECDSA","supportedAlgorithms","name","hash","namedCurve","base64url","DataError","JOSEHeader","data","type","segments","header","protected","unprotected","iv","aad","ciphertext","tag","recipients","payload","signatures","signature","serialization","decode","jwt","ExtendedJWT","startsWith","JSON","parse","error","filter","split","length","encode","token","verified","isJWE","enc","resolveKeys","match","kid","Array","isArray","find","jwk","use","cryptoKey","JWE","encrypt","params","algorithm","subtle","Buffer","from","Uint8Array","toBuffer","Object","assign","usages","push","key_ops","defineProperty","enumerable","value","assertSufficientKeyLength","bitlength","normalizedAlgorithm","typ","cty","jku","x5u","x5c","x5t","crit","zip","isJWS","stringify","pad_string_1","input","encoding","isBuffer","fromBase64","toString","toBase64","default","replace","base64","kty","stringLength","diff","position","padLength","paddedStringLength","buffer","alloc","write","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","globalThis","Function","e","window","__webpack_exports__"],"ignoreList":[],"sourceRoot":""}